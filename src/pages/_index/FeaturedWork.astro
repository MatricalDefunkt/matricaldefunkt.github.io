---
import Spinner from "../../components/ui/Spinner.astro";
import Card from "../../components/ui/Card.astro";
import Badge from "../../components/ui/Badge.astro";
import Link from "../../components/ui/Link.astro";
import Stat from "../../components/ui/Stat.astro";
import IconButton from "../../components/ui/IconButton.astro";

interface Project {
  title: string;
  challenge: string;
  solution: string;
  tech: string[];
  stats: { value: string; label: string }[];
  link?: string;
  linkText?: string;
  image?: string; // small preview shown in card (prefetched)
  imageFull?: string; // full-res image shown in modal (lazy)
}

const projects: Project[] = [
  {
    title: "SELinux Maintainer (AUR)",
    challenge:
      "Keep SELinux packages up-to-date and compatible with Arch Linux's rolling release model, ensuring security and stability for users.",
    solution:
      "Maintain SELinux-related packages in the Arch User Repository (AUR), including regular updates, patching, and responding to user feedback to ensure smooth operation on Arch systems.",
    tech: ["Linux", "Bash", "Package Management"],
    stats: [
      { value: "Active", label: "Maintainer" },
      { value: "168", label: "Stars" },
    ],
    link: "https://github.com/archlinuxhardened/selinux",
    linkText: "View Repository",
  },
  {
    title: "Custom Gitea Runner",
    challenge:
      "Default runners were costly and inefficient for our specific workload patterns.",
    solution:
      "Reverse-engineered the Gitea protocol to build a scale-to-zero runner in Go, orchestrating pods via KEDA.",
    tech: ["Go", "KEDA", "Kubernetes"],
    stats: [
      { value: "20%", label: "Faster Builds" },
      { value: "Zero", label: "Idle Cost" },
    ],
    link: "#",
    linkText: "Proprietary",
    image: "/gitea-runner-autoscaling-small.png",
    imageFull: "/gitea-runner-autoscaling.png",
  },
  {
    title: "Genetic Algorithm Scheduler",
    challenge:
      "Scheduling 4000+ students with conflicting constraints required a robust, local-first solution.",
    solution:
      "Implemented a high-performance scheduling Island Model Genetic Algorithm with TanStack DB for offline-capable, timetable viewing.",
    tech: ["TypeScript", "Node.js Workers", "TanStack DB"],
    stats: [
      { value: "4000+", label: "Students" },
      { value: "500+", label: "Faculties" },
      { value: "800+", label: "Constraints" },
    ],
    link: "https://github.com/pranav-suri/timetable-manager-v3",
    linkText: "View Project",
    image: "/timetable-manager-small.png",
    imageFull: "/timetable-manager.png",
  },
  {
    title: "Node.js Core Contributor",
    challenge:
      "Improving error handling in the experimental SQLite runner was critical for stability.",
    solution:
      "Authored and merged C++ patch (PR #61096) to robustly handle edge cases in the native binding layer.",
    tech: ["C++", "Node.js", "Open Source"],
    stats: [{ value: "PR #61096", label: "Merged" }],
    link: "https://github.com/nodejs/node/pull/61096",
    linkText: "View PR",
  },
];
---

<section>
  <h2>Featured Work & Contributions</h2>
  <div class="grid">
    {
      projects.map((project) => (
        <Card>
          <div class="card-header">
            <h3>
              {project.title === "AUR Maintainer" ? (
                <span>
                  {/* prettier-ignore */}
                  <span class="tooltip" data-tip="Arch, BTW">AUR</span>{" "}
                  Maintainer
                </span>
              ) : (
                project.title
              )}
            </h3>
            {(project.link && project.link !== "#" && (
              <Link href={project.link} external showIcon>
                {project.linkText || "View Code"}
              </Link>
            )) ||
              (project.link === "#" && (
                <span class="project-link">
                  {project.linkText || "Proprietary"}
                </span>
              ))}
          </div>
          <div class="card-body">
            <div class="project-section">
              <strong>The Challenge:</strong> <p>{project.challenge}</p>
            </div>
            <div class="project-section">
              <strong>The Solution:</strong> <p>{project.solution}</p>
            </div>

            <div class="stats-row">
              {project.stats.map((stat) => (
                <Stat value={stat.value} label={stat.label} />
              ))}
            </div>
          </div>
          <div class="card-footer">
            <div class="tags">
              {project.tech.map((t) => (
                <Badge text={t} />
              ))}
            </div>
            {project.image && (
              <div class="chevron-slot">
                <IconButton
                  class="toggle-image-btn"
                  ariaLabel="Show Architecture"
                  title="Show Architecture"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <polyline points="6 9 12 15 18 9" />
                  </svg>
                </IconButton>
              </div>
            )}
          </div>
          {project.image && (
            <div class="project-image-wrapper">
              <div class="project-image">
                <img
                  src={project.image}
                  alt={`Architecture for ${project.title}`}
                  class="expandable-image"
                  data-title={project.title}
                  data-full-src={project.imageFull ?? project.image}
                />
              </div>
            </div>
          )}
        </Card>
      ))
    }
  </div>
</section>

<div
  id="image-modal"
  class="modal-overlay"
  role="dialog"
  aria-modal="true"
  aria-label="Architecture diagram"
>
  <IconButton class="modal-close" ariaLabel="Close modal" variant="modal-close">
    &times;
  </IconButton>
  <div class="modal-content">
    <div id="modal-spinner" aria-hidden="true">
      <Spinner />
    </div>
    <img id="modal-img" src="" alt="" />
    <p id="modal-caption"></p>
  </div>
</div>

<style>
  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 0.5rem;
    margin-bottom: 0.5rem;
    border-bottom: 1px solid var(--card-border);
  }

  .card-header h3 {
    min-width: 0;
    padding-right: 1rem;
  }

  .project-section {
    margin-bottom: 0.75rem;
  }

  .project-section strong {
    color: var(--text-color);
    display: block;
    font-size: 0.9rem;
    margin-bottom: 0.2rem;
  }

  .project-section p {
    font-size: 0.95rem;
    line-height: 1.5;
    margin: 0;
  }

  /* Image Wrapper & Animation */
  .project-image-wrapper {
    display: grid;
    grid-template-rows: 0fr;
    transition:
      grid-template-rows 0.3s ease-out,
      margin-top 0.3s ease-out;
    margin-bottom: 0;
  }

  .project-image-wrapper.expanded {
    grid-template-rows: 1fr;
    margin-top: 1rem;
  }

  .project-image {
    overflow: hidden;
    border-radius: 0.5rem;
    border: 1px solid var(--card-border);
    opacity: 0;
    transition: opacity 0.3s ease-in;
    min-height: 0; /* Important for grid transition */
  }

  img {
    image-rendering: -webkit-optimize-contrast; /* Chrome/Edge */
    image-rendering: crisp-edges;
  }

  .project-image-wrapper.expanded .project-image {
    opacity: 1;
  }

  .project-image img {
    width: 100%;
    height: auto;
    display: block;
    object-fit: cover;
  }

  /* Stats Row */
  .stats-row {
    display: flex;
    gap: 1.5rem;
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px dashed var(--card-border);
  }

  /* Tooltip (shared for AUR and button) */
  .tooltip {
    position: relative;
    cursor: default;
    border-bottom: 1px dotted var(--accent-color);
  }

  .tooltip::after,
  .toggle-image-btn::after {
    background: #3a3935;
    color: var(--text-color);
    font-size: 0.75rem;
    font-weight: 500;
    white-space: nowrap;
    padding: 0.3rem 0.6rem;
    border-radius: 4px;
    border: 1px solid #52504b;
    pointer-events: none;
    opacity: 0;
    transition:
      opacity 0.15s ease,
      transform 0.15s ease;
    z-index: 100;
    position: absolute;
  }

  .tooltip::after {
    content: attr(data-tip);
    bottom: calc(100% + 6px);
    left: 50%;
    transform: translateX(-50%) scale(0.85);
  }

  .tooltip:hover::after {
    opacity: 1;
    transform: translateX(-50%) scale(1);
  }

  /* Footer & Chevron Button */
  .card-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: auto;
    padding-top: 1rem;
    gap: 0.5rem;
  }

  .tags {
    display: flex;
    flex-wrap: wrap;
    flex: 1;
    min-width: 0;
  }

  .chevron-slot {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    margin-left: auto;
  }

  .toggle-image-btn {
    background: var(--card-bg);
    border: 4px solid var(--card-border);
    color: var(--accent-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.4rem;
    border-radius: 4px;
    transition: all 0.2s;
    position: relative;
    flex-shrink: 0; /* Don't shrink */
  }

  .toggle-image-btn:hover {
    color: var(--text-color);
    border-color: var(--accent-color);
    background-color: #2c2b27;
  }

  /* Modal / Lightbox */
  .modal-overlay {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.75);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    padding: 2rem;
    overflow: hidden;
  }

  .modal-overlay.open {
    opacity: 1;
    pointer-events: all;
  }

  .modal-content {
    position: relative;
    max-width: 90vw;
    max-height: 85vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.75rem;
    transform: scale(0.92);
    transition: transform 0.2s ease;
  }

  .modal-overlay.open .modal-content {
    transform: scale(1);
  }

  /* Loading spinner */
  #modal-spinner {
    display: none;
    align-items: center;
    justify-content: center;
    width: 90vw;
    height: 12rem;
    color: var(--accent-color);
  }

  #modal-spinner.visible {
    display: flex;
  }

  .modal-content img {
    width: 90vw;
    max-height: 85vh;
    height: auto;
    object-fit: contain;
    border-radius: 0.5rem;
    border: 1px solid var(--card-border);
    display: block;
    transform-origin: center center;
    touch-action: none;
    user-select: none;
    -webkit-user-drag: none;
    cursor: zoom-in; /* Default state */
  }

  .modal-content img.zoomed {
    cursor: grab;
  }
  .modal-content img.dragging {
    cursor: grabbing;
  }

  #modal-caption {
    color: var(--secondary-text);
    font-size: 0.85rem;
    margin: 0;
  }

  .expandable-image {
    cursor: zoom-in;
  }
</style>
<script>
  {
    // Eagerly preload all architecture images into the browser cache so that
    // chevron expansion and modal open never trigger a fresh network request.
    // Preload only the small preview images (full-res images are loaded lazily on modal open)
    document
      .querySelectorAll<HTMLImageElement>(".expandable-image")
      .forEach((img) => {
        const url = img.getAttribute("src") ?? "";
        if (url && !img.complete) {
          const preload = new Image();
          preload.src = url;
        }
      });

    const buttons = document.querySelectorAll(".toggle-image-btn");

    buttons.forEach((button) => {
      button.addEventListener("click", () => {
        const card = button.closest(".card");
        if (!card) return;

        const imageWrapper = card.querySelector(".project-image-wrapper");

        if (imageWrapper && imageWrapper instanceof HTMLElement) {
          button.classList.toggle("active");
          imageWrapper.classList.toggle("expanded");

          if (button.classList.contains("active")) {
            button.setAttribute("data-tooltip", "Hide Architecture");
            button.setAttribute("aria-label", "Hide Architecture");
          } else {
            button.setAttribute("data-tooltip", "Show Architecture");
            button.setAttribute("aria-label", "Show Architecture");
          }
        }
      });
    });

    // Modal lightbox
    const modal = document.getElementById("image-modal") as HTMLElement | null;
    const modalImg = document.getElementById(
      "modal-img",
    ) as HTMLImageElement | null;
    const modalCaption = document.getElementById(
      "modal-caption",
    ) as HTMLElement | null;
    const closeBtn = modal?.querySelector(".modal-close") as HTMLElement | null;
    const modalSpinner = document.getElementById(
      "modal-spinner",
    ) as HTMLElement | null;

    // --- Zoom / pan state ---
    let scale = 1;
    let originX = 0;
    let originY = 0;
    const MIN_SCALE = 1;
    const MAX_SCALE = 8;

    // Cached dimensions — updated once on resize/open to prevent DOM Reflow thrashing
    let imgBaseWidth = 0;
    let imgBaseHeight = 0;
    let winWidth = 0;
    let winHeight = 0;
    let rafPending = false;

    function updateDimensions() {
      if (!modalImg) return;
      imgBaseWidth = modalImg.offsetWidth;
      imgBaseHeight = modalImg.offsetHeight;
      winWidth = window.innerWidth;
      winHeight = window.innerHeight;
    }

    function clampOrigin() {
      const iw = imgBaseWidth * scale;
      const ih = imgBaseHeight * scale;
      const maxX = Math.max(0, (iw - winWidth) / 2);
      const maxY = Math.max(0, (ih - winHeight) / 2);
      originX = Math.max(-maxX, Math.min(maxX, originX));
      originY = Math.max(-maxY, Math.min(maxY, originY));
    }

    function updateCursorClass() {
      if (!modalImg) return;
      if (isDragging) {
        modalImg.classList.add("dragging");
        modalImg.classList.remove("zoomed");
      } else if (scale > 1) {
        modalImg.classList.add("zoomed");
        modalImg.classList.remove("dragging");
      } else {
        modalImg.classList.remove("zoomed", "dragging");
      }
    }

    function applyTransform() {
      if (!modalImg) return;
      clampOrigin();
      // Use translate3d to enforce hardware GPU acceleration
      modalImg.style.transform = `translate3d(${originX}px, ${originY}px, 0) scale(${scale})`;
    }

    // Schedule a single rAF-batched paint — drops redundant mid-frame calls
    function scheduleTransform() {
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame(() => {
        rafPending = false;
        applyTransform();
      });
    }

    function setWillChange(active: boolean) {
      if (!modalImg) return;
      modalImg.style.willChange = active ? "transform" : "auto";
    }

    function resetZoom() {
      scale = 1;
      originX = 0;
      originY = 0;
      setWillChange(false);
      updateCursorClass();
      applyTransform();
    }

    window.addEventListener("resize", updateDimensions, { passive: true });

    function openModal(src: string, alt: string) {
      if (!modal || !modalImg || !modalCaption) return;
      resetZoom();
      modalImg.alt = alt;
      modalCaption.textContent = `Architecture: ${alt}`;
      modal.classList.add("open");
      document.body.style.overflow = "hidden";

      // Show spinner while full-res image decodes, then swap in the image
      modalImg.style.display = "none";
      modalSpinner?.classList.add("visible");

      // Force Chrome to decode at full resolution rather than reusing the
      // downscaled texture it cached from the small inline card preview.
      // decode() returns a promise that resolves once the image is fully
      // decoded at the size it will actually be rendered.
      modalImg.src = src;
      modalImg
        .decode()
        .then(() => {
          modalSpinner?.classList.remove("visible");
          modalImg.style.display = "";
          requestAnimationFrame(updateDimensions);
        })
        .catch(() => {
          modalSpinner?.classList.remove("visible");
          modalImg.style.display = "";
          requestAnimationFrame(updateDimensions);
        });
    }

    function closeModal() {
      if (!modal || !modalImg) return;
      modal.classList.remove("open");
      document.body.style.overflow = "";
      modalSpinner?.classList.remove("visible");
      setTimeout(() => {
        if (!modal.classList.contains("open")) {
          modalImg.src = "";
          modalImg.style.display = "";
          resetZoom();
        }
      }, 200);
    }

    document.querySelectorAll(".expandable-image").forEach((img) => {
      img.addEventListener("click", () => {
        const el = img as HTMLImageElement;
        // Use full-res image for modal; fall back to preview src if not specified
        const fullSrc = el.dataset.fullSrc ?? el.src;
        openModal(fullSrc, el.dataset.title ?? el.alt);
      });
    });

    closeBtn?.addEventListener("click", closeModal);

    modal?.addEventListener("click", (e) => {
      if (e.target === modal) closeModal();
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeModal();
    });

    // --- Scroll (wheel) zoom ---
    modalImg?.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();

        // Normalize scroll delta between trackpads and discrete mouse wheels
        let dy = e.deltaY;
        if (e.deltaMode === 1)
          dy *= 33; // DOM_DELTA_LINE
        else if (e.deltaMode === 2) dy *= winHeight; // DOM_DELTA_PAGE

        // Smooth scaling factor utilizing an exponential curve (prevents instant trackpad blowups)
        const zoomFactor = Math.exp(-dy * 0.0015);
        const next = Math.min(
          MAX_SCALE,
          Math.max(MIN_SCALE, scale * zoomFactor),
        );

        if (next === MIN_SCALE) {
          originX = 0;
          originY = 0;
          setWillChange(false);
        } else {
          setWillChange(true);
        }

        scale = next;
        updateCursorClass();
        scheduleTransform();
      },
      { passive: false },
    );

    // --- Mouse drag to pan ---
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };

    modalImg?.addEventListener("mousedown", (e) => {
      if (scale <= 1) return;
      isDragging = true;
      setWillChange(true);
      dragStart = { x: e.clientX - originX, y: e.clientY - originY };
      updateCursorClass();
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDragging || !modalImg) return;
      originX = e.clientX - dragStart.x;
      originY = e.clientY - dragStart.y;
      scheduleTransform(); // Batched to prevent main-thread locking
    });

    window.addEventListener("mouseup", () => {
      if (!isDragging) return;
      isDragging = false;
      setWillChange(false);
      updateCursorClass();
    });

    modalImg?.addEventListener("dblclick", (e) => {
      e.stopPropagation();
      if (scale === MIN_SCALE) {
        // Zoom in to 2x centered on click position
        const rect = modalImg.getBoundingClientRect();
        const clickX = e.clientX - rect.left - rect.width / 3;
        const clickY = e.clientY - rect.top - rect.height / 3;

        scale = 2;
        originX = -clickX;
        originY = -clickY;
        setWillChange(true);
        updateCursorClass();
        scheduleTransform();
      } else {
        resetZoom();
      }
    });

    // --- Touch: pinch to zoom + single-finger pan ---
    let lastPinchDist = 0;
    let lastTouchX = 0;
    let lastTouchY = 0;

    modalImg?.addEventListener(
      "touchstart",
      (e) => {
        if (e.touches.length === 2) {
          lastPinchDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY,
          );
        } else if (e.touches.length === 1) {
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
        }
      },
      { passive: true },
    );

    modalImg?.addEventListener(
      "touchmove",
      (e) => {
        e.preventDefault();
        if (e.touches.length === 2) {
          const dist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY,
          );
          const factor = dist / lastPinchDist;
          scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * factor));
          lastPinchDist = dist;
          if (scale === MIN_SCALE) {
            originX = 0;
            originY = 0;
            setWillChange(false);
          } else {
            setWillChange(true);
          }
          updateCursorClass();
          scheduleTransform();
        } else if (e.touches.length === 1 && scale > 1) {
          originX += e.touches[0].clientX - lastTouchX;
          originY += e.touches[0].clientY - lastTouchY;
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
          scheduleTransform(); // Batched here as well
        }
      },
      { passive: false },
    );
  }
</script>
